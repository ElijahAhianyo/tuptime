#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""tuptime - Report the historical and statistical real time of the system,
keeping it between restarts."""
# Copyright (C) 2011-2020 - Ricardo F.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys, os, argparse, locale, platform, signal, logging, sqlite3, time
from datetime import datetime


DB_FILE = '/var/lib/tuptime/tuptime.db'
DATE_FORMAT = '%X %x'
ZIP = False
__version__ = '5.0.0'

# Terminate when SIGPIPE signal is received
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

# Set locale to the userâ€™s default settings (LANG env. var)
try:
    locale.setlocale(locale.LC_ALL, '')
except Exception:
    pass  # Fast than locale.setlocale(locale.LC_ALL, 'C')


def get_arguments():
    """Get arguments from command line"""

    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group()
    parser.add_argument(
        '-A', '--at',
        dest='at',
        default=None,
        action='store',
        metavar='STARTUP',
        type=int,
        help='restrict at this startup number'
    )
    parser.add_argument(
        '-b', '--bootid',
        dest='bootid',
        action='store_true',
        default=False,
        help='print boot identifier information'
    )
    parser.add_argument(
        '-c', '--csv',
        dest='csv',
        action='store_true',
        default=False,
        help='csv output'
    )
    parser.add_argument(
        '-d', '--date',
        dest='date_format',
        default=DATE_FORMAT,
        action='store',
        help='date format output'
    )
    parser.add_argument(
        '--decp',
        dest='decp',
        default=2,
        metavar='DECIMALS',
        action='store',
        type=int,
        help='number of decimals in percentages'
    )
    parser.add_argument(
        '-f', '--filedb',
        dest='db_file',
        default=DB_FILE,
        action='store',
        help='database file (' + DB_FILE + ')',
        metavar='FILE'
    )
    parser.add_argument(
        '-g', '--graceful',
        dest='endst',
        action='store_const',
        default=int(0),
        const=int(1),
        help='register a graceful shutdown'
    )
    parser.add_argument(
        '-k', '--kernel',
        dest='kernel',
        action='store_true',
        default=False,
        help='print kernel information'
    )
    group.add_argument(
        '-l', '--list',
        dest='lst',
        default=False,
        action='store_true',
        help='enumerate system life as list'
    )
    parser.add_argument(
        '-n', '--noup',
        dest='update',
        default=True,
        action='store_false',
        help='avoid update values into db'
    )
    parser.add_argument(
        '-o', '--order',
        dest='order',
        metavar='TYPE',
        default=False,
        action='store',
        type=str,
        choices=['e', 'd', 'k', 'u', 'r', 's'],
        help='order enumerate by [<e|d|k|u|r|s>]'
    )
    parser.add_argument(
        '-p', '--power',
        dest='power',
        default=False,
        action='store_true',
        help='print power states run + sleep'
    )
    parser.add_argument(
        '-r', '--reverse',
        dest='reverse',
        default=False,
        action='store_true',
        help='reverse order in list or table output'
    )
    parser.add_argument(
        '-s', '--seconds',
        dest='seconds',
        default=False,
        action='store_true',
        help='output time in seconds and epoch'
    )
    parser.add_argument(
        '-S', '--since',
        dest='since',
        default=0,
        action='store',
        metavar='STARTUP',
        type=int,
        help='restrict from this startup number'
    )
    group.add_argument(
        '-t', '--table',
        dest='table',
        default=False,
        action='store_true',
        help='enumerate system life as table'
    )
    group.add_argument(
        '--tat',
        dest='tat',
        metavar='TIMESTAMP',
        default=None,
        action='store',
        type=int,
        help='status at epoch timestamp'
    )
    parser.add_argument(
        '--tsince',
        dest='ts',
        metavar='TIMESTAMP',
        default=None,
        action='store',
        type=int,
        help='restrict from this epoch timestamp'
    )
    parser.add_argument(
        '--tuntil',
        dest='tu',
        metavar='TIMESTAMP',
        default=None,
        action='store',
        type=int,
        help='restrict until this epoch timestamp'
    )
    parser.add_argument(
        '-U', '--until',
        dest='until',
        default=0,
        action='store',
        metavar='STARTUP',
        type=int,
        help='restrict up until this startup number'
    )
    parser.add_argument(
        '-v', '--verbose',
        dest='verbose',
        default=False,
        action='store_true',
        help='verbose output'
    )
    parser.add_argument(
        '-V', '--version',
        action='version',
        version='tuptime version ' + (__version__),
        help='show version'
    )
    parser.add_argument(
        '-x', '--silent',
        dest='silent',
        default=False,
        action='store_true',
        help='update values into db without output'
    )
    parser.add_argument(
        '-z', '--zip',
        dest='zip',
        default=False,
        action='store_true',
        help='narrow date style'
    )
    arg = parser.parse_args()

    # Check enable verbose
    if arg.verbose:
        logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)
        logging.info('Version = %s', (__version__))

    # Check combination of operator requirements
    if arg.reverse or arg.order:
        if not arg.table and not arg.lst:
            parser.error('Used operators must be combined with [-t|--table] or [-l|--list].')
        if arg.order == 'k':
            if not arg.kernel:
                logging.info('Auto enable option = kernel')
                arg.kernel = True
        if arg.order == 'r' or arg.order == 's':
            if not arg.power:
                logging.info('Auto enable option = power')
                arg.power = True

    # Wrap 'at' over since and until
    if arg.at is not None:
        if arg.at < 0:
            arg.at = arg.at + 1
        arg.since = -1
        arg.until = arg.at

    if ((arg.ts or arg.tu) and (arg.power or arg.tat)) or (arg.tat and arg.power):
        # Power states report accumulated time across an uptime range, is not possible to
        # know if the state was running or sleeping between specific points insde it.
        # Narrow ranges can cut the btime and offbtime info, it doesn't make sense with
        # 'at' argument report.
        parser.error('Operator can\'t be combined with [--tsince] or [--tuntil]')

    if arg.zip:
        global ZIP
        ZIP = True

    logging.info('Arguments = %s', str(vars(arg)))
    return arg


def get_os_values():
    """Get values from each type of operating system"""

    sis = {'bootid': None, 'btime': None, 'uptime': None, 'rntime': None, 'slptime': None, 'offbtime': None, 'downtime': None, 'kernel': None}

    def os_bsd(sis):
        """Get values from BSD"""

        logging.info('System = BSD')

        try:
            sis['btime'] = time.clock_gettime(time.CLOCK_REALTIME) - time.clock_gettime(time.CLOCK_MONOTONIC)
        except Exception as exp:
            logging.info('Old btime assignment. %s', str(exp))
            for path in os.environ["PATH"].split(os.pathsep):
                sysctl_bin = os.path.join(path, 'sysctl')
                if os.path.isfile(sysctl_bin) and os.access(sysctl_bin, os.X_OK):
                    break
            sysctl_out = os.popen(sysctl_bin + ' -n kern.boottime').read()
            # Some BSDs report the value assigned to 'sec', others do it directly
            if 'sec' in sysctl_out:  # FreeBSD, Darwin
                sis['btime'] = sysctl_out.split(' sec = ')[1].split(',')[0]
            else:  # OpenBSD, NetBSD
                sis['btime'] = sysctl_out

        try:
            # Time since some unspecified starting point. Contains sleep time on BSDs.
            sis['uptime'] = time.clock_gettime(time.CLOCK_MONOTONIC)
            if sys.platform.startswith(('darwin')):
                # OSX > 10.12 have only UPTIME_RAW. Avoid compare it with non _RAW
                # counters. Their reference here is CLOCK_REALTIME, so remove the raw drift:
                uptime_raw = time.clock_gettime(time.CLOCK_MONOTONIC_RAW)
                raw_diff = sis['uptime'] - uptime_raw
                # Time the system have been running. Not contains sleep time on OSX.
                rntime_raw = time.clock_gettime(time.CLOCK_UPTIME_RAW)
                sis['rntime'] = rntime_raw + raw_diff
            else:
                # Time the system have been running. Not contains sleep time on BSDs.
                sis['rntime'] = time.clock_gettime(time.CLOCK_UPTIME)
        except Exception as exp:
            logging.info('Old uptime/rntime assignment. %s', str(exp))
            logging.info('Power states disabled, values assigned from uptime')
            sis['uptime'] = time.time() - sis['btime']
            sis['rntime'] = sis['uptime']

        return sis

    def os_linux(sis):
        """Get values from Linux"""

        logging.info('System = Linux')

        try:
            sis['btime'] = time.clock_gettime(time.CLOCK_REALTIME) - time.clock_gettime(time.CLOCK_BOOTTIME)
        except Exception as exp:
            logging.info('Old btime assignment. %s', str(exp))
            with open('/proc/stat') as fl2:
                for line in fl2:
                    if line.startswith('btime'):
                        sis['btime'] = line.split()[1]

        try:  # uptime and rntime must be toghether to avoid time mismatch between them
            # Time since some unspecified starting point. Contains sleep time on linux.
            sis['uptime'] = time.clock_gettime(time.CLOCK_BOOTTIME)
            # Time since some unspecified starting point. Not contains sleep time on linux.
            sis['rntime'] = time.clock_gettime(time.CLOCK_MONOTONIC)
        except Exception as exp:
            logging.info('Old uptime/rntime assignment. %s', str(exp))
            logging.info('Power states disabled, values assigned from uptime')
            with open('/proc/uptime') as fl1:
                sis['uptime'] = fl1.readline().split()[0]
            sis['rntime'] = sis['uptime']

        try:
            with open('/proc/sys/kernel/random/boot_id') as fl3:
                sis['bootid'] = fl3.readline().split()[0]
        except Exception as exp:
            logging.info('Linux boot_id not assigned')

        return sis

    # Linux
    if sys.platform.startswith('linux'):
        sis = os_linux(sis)
    # BSDs
    elif sys.platform.startswith(('freebsd', 'darwin', 'dragonfly', 'openbsd', 'netbsd')):
        sis = os_bsd(sis)
    # elif:
    #     other_os()
    else:
        logging.error('System = %s not supported', sys.platform)
        sys.exit(-1)

    # All OS values as integer
    sis['btime'] = int(round(float(sis['btime']), 0))
    sis['uptime'] = int(round(float(sis['uptime']), 0))
    sis['rntime'] = int(round(float(sis['rntime']), 0))

    # Avoid missmatch whith elapsed time between getting counters and/or rounded values,
    # whit less than 1 seconds, values are equal
    if (sis['uptime'] - 1) <= sis['rntime'] <= (sis['uptime'] + 1):
        sis['rntime'] = sis['uptime']

    # Get sleep time from runtime
    sis['slptime'] = sis['uptime'] - sis['rntime']

    sis['kernel'] = platform.platform()
    logging.info('Python = %s', str(platform.python_version()))

    try:
        logging.info('Current locale = %s', str(locale.getlocale()))
    except:
        pass
    logging.info('Boot ID = %s', str(sis['bootid']))
    logging.info('Uptime = %s', str(sis['uptime']))
    logging.info('Rntime = %s', str(sis['rntime']))
    logging.info('Slptime = %s', str(sis['slptime']))
    logging.info('Btime = %s', str(sis['btime']))
    logging.info('Kernel = %s', str(sis['kernel']))
    logging.info('Execution user = %s', str(os.getuid()))

    # Check right allocation of variables before continue and fix when possible
    for osvarkey, osvarvalue in {'btime': sis['btime'], 'uptime': sis['uptime'], 'rntime': sis['rntime'], 'slptime': sis['slptime'], 'kernel': sis['kernel']}.items():
        if osvarvalue is None:
            logging.error('%s value unallocate from system. Can\'t continue.', str(osvarkey))
            sys.exit(-1)
        if osvarkey in {'uptime', 'rntime', 'slptime'} and osvarvalue < 0:
            logging.warning('Invalid %s value \"%s\". Reset to \"0\"', str(osvarkey), str(osvarvalue))
            if osvarkey == 'uptime': sis['uptime'] = 0
            if osvarkey == 'rntime': sis['rntime'] = 0
            if osvarkey == 'slptime': sis['slptime'] = 0

    # Avoid executing when OS clock is too out of phase
    if sis['btime'] < 946684800:   # 01/01/2000 00:00
        logging.error('Epoch boot time value is too old \'%s\'. Check system clock sync.', str(sis['btime']))
        logging.error('Tuptime execution can\'t continue.')
        sys.exit(-1)

    return sis


def assure_state_db(sis, arg):
    """Assure state of db file and related directories"""

    if arg.db_file == DB_FILE:  # If db_file keeps default value
        # Check for DB environment variable
        if os.environ.get('TUPTIME_DBF'):
            arg.db_file = os.environ.get('TUPTIME_DBF')
            logging.info('DB environ var = %s', str(arg.db_file))

    # Test path
    arg.db_file = os.path.abspath(arg.db_file)  # Get absolute or relative path
    try:
        if os.path.isdir(os.path.dirname(arg.db_file)):
            logging.info('Directory exists = %s', str(os.path.dirname(arg.db_file)))
        else:
            logging.info('Creating path = %s', str(os.path.dirname(arg.db_file)))
            os.makedirs(os.path.dirname(arg.db_file))
    except Exception as exp_path:
        logging.error('Checking DB path "%s": %s', str(os.path.dirname(arg.db_file)), str(exp_path))
        sys.exit(-1)

    # Test and create db with the initial values
    try:
        if os.path.isfile(arg.db_file):
            logging.info('DB file exists = %s', str(arg.db_file))
        else:
            logging.info('Creating DB file = %s', str(arg.db_file))
            db_conn = sqlite3.connect(arg.db_file)
            conn = db_conn.cursor()
            conn.execute('create table if not exists tuptime'
                         '(bootid text, btime integer, uptime integer, rntime integer, slptime integer,'
                         'offbtime integer, endst integer, downtime integer, kernel text)')
            conn.execute('insert into tuptime values (?,?,?,?,?,?,?,?,?)',
                         (str(sis['bootid']), str(sis['btime']), str(sis['uptime']),
                          str(sis['rntime']), str(sis['slptime']), None,
                          str(arg.endst), None, str(sis['kernel'])))
            db_conn.commit()
            db_conn.close()
    except Exception as exp_file:
        logging.error('Checking DB file "%s": %s', str(arg.db_file), str(exp_file))
        sys.exit(-1)


def upgrade_db(db_conn, conn, columns, arg):
    """Upgrade db to current format"""

    if not os.access(arg.db_file, os.W_OK):
        logging.error('"%s" file not writable by execution user.', str(arg.db_file))
        sys.exit(-1)
    logging.warning('Upgrading DB file = %s', str(arg.db_file))

    try:

        if 'rntime' and 'slptime' not in columns:  # tuptime v4
            logging.warning('Upgrading DB with power states')
            conn.execute('create table if not exists tuptimeNew'
                         '(btime integer, uptime integer, rntime integer, slptime integer,'
                         'offbtime integer, endst integer, downtime integer, kernel text)')
            conn.execute('update tuptime set uptime = cast(round(uptime) as int)')
            conn.execute('update tuptime set offbtime = cast(round(offbtime) as int)')
            conn.execute('update tuptime set downtime = cast(round(downtime) as int)')
            conn.execute('insert into tuptimeNew '
                         '(btime, uptime, offbtime, endst, downtime, kernel) '
                         'SELECT btime, uptime, offbtime, endst, downtime, kernel '
                         'FROM tuptime')
            conn.execute('update tuptimeNew set rntime = uptime')
            conn.execute('update tuptimeNew set slptime = 0')
            conn.execute('drop table tuptime')
            conn.execute('alter table tuptimeNew RENAME TO tuptime')
            db_conn.commit()

        if 'bootid' not in columns:  # tuptime v5
            logging.warning('Upgrading DB with boot ID')
            conn.execute('create table if not exists tuptimeNew'
                         '(bootid text, btime integer, uptime integer, rntime integer, slptime integer,'
                         'offbtime integer, endst integer, downtime integer, kernel text)')
            conn.execute('insert into tuptimeNew '
                         '(btime, uptime, rntime, slptime, offbtime, endst, downtime, kernel) '
                         'SELECT btime, uptime, rntime, slptime, offbtime, endst, downtime, kernel '
                         'FROM tuptime')
            conn.execute('drop table tuptime')
            conn.execute('alter table tuptimeNew RENAME TO tuptime')
            db_conn.commit()

    except Exception as exp_db:
        logging.error('Upgrading DB format failed. "%s"', str(exp_db))
        sys.exit(-1)

    logging.warning('Upgraded')


def control_drift(prev, sis):
    """Check time drift due inconsistencies with system clock"""

    offset = sis['btime'] - prev['btime']  # Calculate time offset
    logging.info('Drift over btime = %s', str(offset))

    # If previous btime doesn't match
    if prev['btime'] != sis['btime']:
        logging.info('Fixing drift...')

        # Apply offset to uptime and btime
        if sis['uptime'] > offset and (sis['uptime'] + offset) > 0:
            logging.info('System timestamp = %s', str(sis['btime'] + sis['uptime']))

            sis['uptime'] = sis['uptime'] + offset
            logging.info('Fixed uptime = %s', str(sis['uptime']))

            sis['rntime'] = sis['rntime'] + offset
            if sis['rntime'] < 1:
                sis['slptime'] = sis['slptime'] + sis['rntime']
                if sis['slptime'] < 0:
                    logging.info('Drift decrease slptime under 0. Impossible')
                    sis['slptime'] = 0
                logging.info('Drift decrease rntime under 1. Impossible')
                sis['rntime'] = 1
            logging.info('Fixed rntime = %s', str(sis['rntime']))
            logging.info('Fixed slptime = %s', str(sis['slptime']))

            sis['btime'] = sis['btime'] - offset
            logging.info('Fixed btime = %s', str(sis['btime']))
            logging.info('Fixed timestamp = %s', str(sis['btime'] + sis['uptime']))
            # Fixed timestamp must be equal to system timestamp after drift values
            # Fixed btime must be equal to last btime from db

        else:
            # Keep btime from db with current uptime until it can be fixed
            sis['btime'] = prev['btime']
            logging.info('Keep last btime from DB = %s', str(sis['btime']))
            if sis['uptime'] <= offset:
                logging.info('Drift is bigger or equal than uptime. Skipping')
            if (sis['uptime'] + offset) <= 0:
                logging.info('Drift decreases uptime under 1. Skipping')

    return sis


def time_conv(secs):
    """Convert seconds to human readable syle"""

    # Ouptut style:
    #  Large --> 4 years, 172 days, 16 hours, 4 minutes and 13 seconds
    #  Short --> 04y 172d 16h 04m 13s

    # Dict to store values
    dtm = {'years': 0, 'days': 0, 'hours': 0, 'minutes': 0, 'seconds': 0}
    line = ''

    # Calculate values
    dtm['minutes'], dtm['seconds'] = divmod(secs, 60)
    dtm['hours'], dtm['minutes'] = divmod(dtm['minutes'], 60)
    dtm['days'], dtm['hours'] = divmod(dtm['hours'], 24)
    dtm['years'], dtm['days'] = divmod(dtm['days'], 365)

    # Construct date sentence
    for key in ('years', 'days', 'hours', 'minutes', 'seconds'):

        # Avoid print empty values at the beginning
        if (dtm[key] == 0) and (line == '') and (key != 'seconds'):
            continue
        else:
            if ZIP:
                line += str(dtm[key]) + key[0] + ' '
            else:
                if (dtm[key]) == 1:  # Not plural for 1 unit
                    line += str(dtm[key]) + ' ' + str(key[:-1]) + ', '
                else:
                    line += str(dtm[key]) + ' ' + str(key) + ', '

    if ZIP:
        # Return without last space char
        return str(line[:-1])
    else:
        # Return without last comma and space char
        return str(line[:-2])


def since_opt(db_rows, arg):
    """Get rows since a given row startup number registered"""

    if arg.since < 0:  # Negative value start from bottom
        arg.since = db_rows[-1]['startup'] + arg.since + 1

    # Remove rows if the startup is lower
    for row in db_rows[:]:
        if arg.since > row['startup']:
            db_rows.remove(row)

    return db_rows, arg


def until_opt(db_rows, arg):
    """Get rows until a given row startup number registered"""

    if arg.until < 0:  # Negative value start from bottom
        arg.until = db_rows[-1]['startup'] + arg.until

    # Remove row if the startup is greater
    for row in db_rows[:]:
        if arg.until < row['startup']:
            db_rows.remove(row)

    return db_rows, arg


def tuntil_opt(db_rows, sis, arg):
    """Split and report rows until a given timestamp

    Conventions:
        - Each row keeps its startup number and boot ID
        - Empty values are False
    """

    # Negative value decrease actual timestamp
    if arg.tu < 0:
        arg.tu = sis['btime'] + sis['uptime'] + arg.tu

    # Find a match along all rows and get the offset
    offset = None
    for ind, row in enumerate(db_rows[:]):

        if offset is not None:
            db_rows.remove(row)

        elif arg.tu > row['offbtime'] and arg.tu <= (row['offbtime'] + row['downtime']):
            offset = arg.tu - row['offbtime']
            db_rows[ind]['downtime'] = offset

        elif arg.tu > row['btime'] and arg.tu <= (row['btime'] + row['uptime']):
            offset = arg.tu - row['btime']
            db_rows[ind]['uptime'] = offset
            db_rows[ind]['rntime'] = db_rows[ind]['slptime'] = False
            db_rows[ind]['offbtime'] = False
            db_rows[ind]['endst'] = False
            db_rows[ind]['downtime'] = False

        elif arg.tu <= row['btime']:
            offset = True
            db_rows.remove(row)

    return db_rows, arg


def tsince_opt(db_rows, sis, arg):
    """Split and report rows since a given timestamp

    Conventions:
        - Each row keeps its startup number and boot ID
        - Empty values are False
    """

    # Negative value decrease actual timestamp
    if arg.ts < 0:
        arg.ts = sis['btime'] + sis['uptime'] + arg.ts

    # Find a match along all rows and get the offset
    offset = None
    for row in db_rows[:]:

        if arg.ts <= row['btime']:
            offset = True

        elif arg.ts > row['btime'] and arg.ts < (row['btime'] + row['uptime']):
            offset = row['btime'] + row['uptime'] - arg.ts
            db_rows[0]['btime'] = False
            db_rows[0]['uptime'] = offset
            db_rows[0]['rntime'] = db_rows[0]['slptime'] = False

        elif arg.ts == row['offbtime']:
            offset = True
            db_rows[0]['btime'] = False
            db_rows[0]['uptime'] = False
            db_rows[0]['rntime'] = db_rows[0]['slptime'] = False

        elif arg.ts > row['offbtime'] and arg.ts < (row['offbtime'] + row['downtime']):
            offset = row['offbtime'] + row['downtime'] - arg.ts
            db_rows[0]['btime'] = False
            db_rows[0]['uptime'] = False
            db_rows[0]['rntime'] = db_rows[0]['slptime'] = False
            db_rows[0]['offbtime'] = False
            db_rows[0]['downtime'] = offset

        elif offset is None:
            db_rows.remove(row)

    return db_rows, arg


def ordering_output(db_rows, arg):
    """Order output"""

    if db_rows:
        if arg.order and (arg.order in ('e', 'd', 'k', 'u', 'r', 's')):

            match_value = {'u': 'uptime', 'e': 'endst', 'd': 'downtime', 'k': 'kernel', 'r': 'rntime', 's': 'slptime'}
            db_rows = sorted(db_rows, key=lambda x: (x[match_value[arg.order]]))

        if arg.reverse:
            db_rows = list(reversed(db_rows))
    else:
        db_rows = [{'startup': 0, 'bootid': None, 'uptime': False, 'rntime': False, 'slptime': False,
                    'endst': False, 'offbtime': False, 'btime': False, 'downtime': False, 'kernel': None}]

    return db_rows


def for_print(db_rows, arg):
    """Prepare values for print"""

    remap = []  # To store processed list

    # Based if the value is False or not, set the right content format
    for row in db_rows:

        if row['bootid'] is None:
            row['bootid'] = ''

        if row['btime'] is not False:
            if not arg.seconds:
                row['btime'] = datetime.fromtimestamp(row['btime']).strftime(arg.date_format)
        else:
            row['btime'] = ''

        if row['uptime'] is not False:
            if not arg.seconds:
                row['uptime'] = time_conv(row['uptime'])
                row['rntime'] = time_conv(row['rntime'])
                row['slptime'] = time_conv(row['slptime'])
            else:
                row['uptime'] = row['uptime']
                row['rntime'] = row['rntime']
                row['slptime'] = row['slptime']
        else:
            row['uptime'] = ''
            row['rntime'] = ''
            row['slptime'] = ''

        if row['endst'] is not False:
            if row['offbtime'] is not False or row['downtime'] is not False:
                if row['endst'] == 1:
                    row['endst'] = 'OK'
                elif row['endst'] == 0:
                    row['endst'] = 'BAD'
            else:
                row['endst'] = ''
        else:
            row['endst'] = ''

        if row['offbtime'] is not False:
            if not arg.seconds:
                row['offbtime'] = datetime.fromtimestamp(row['offbtime']).strftime(arg.date_format)
        else:
            row['offbtime'] = ''

        if row['downtime'] is not False:
            if not arg.seconds:
                row['downtime'] = time_conv(row['downtime'])
            else:
                row['downtime'] = row['downtime']
        else:
            row['downtime'] = ''

        if row['kernel'] is None:
            row['kernel'] = ''

        remap.append(row)
    return remap


def print_list(db_rows, arg):
    """Print values as list"""

    db_rows = ordering_output(db_rows, arg)

    for row_dict in for_print(db_rows, arg):

        if not arg.csv:  # Define content/spaces between values
            sp0, sp1 = '', '  '
            sp2, sp3, sp4 = ': ', ':  ', ':   '

        else:
            sp0 = '"'
            sp4 = sp3 = sp2 = sp1 = '","'

        if row_dict['btime']:
            print(sp0 + 'Startup' + sp3 + str(row_dict['startup']) + sp1 + 'at' + sp1 + str(row_dict['btime']) + sp0)
        else:
            if not arg.csv:
                print(sp0 + 'Startup' + sp3 + str(row_dict['startup']) + sp0)
            else:  # Consistent csv output, always with the same number of values
                print(sp0 + 'Startup' + sp3 + str(row_dict['startup']) + sp1 + '' + sp1 + '' + sp0)

        if arg.bootid and row_dict['bootid']:
            print(sp0 + 'Boot ID' + sp3 + str(row_dict['bootid']) + sp0)

        if row_dict['uptime']:
            print(sp0 + 'Uptime' + sp4 + str(row_dict['uptime']) + sp0)

            if arg.power:
                print(sp0 + 'Running' + sp3 + str(row_dict['rntime']) + sp0)
                print(sp0 + 'Sleeping' + sp3 + str(row_dict['slptime']) + sp0)

        if row_dict['offbtime'] and row_dict['endst']:
            print(sp0 + 'Shutdown' + sp2 + str(row_dict['endst']) + sp1 + 'at' + sp1 + str(row_dict['offbtime']) + sp0)

        elif row_dict['endst']:
            if not arg.csv:
                print(sp0 + 'Shutdown' + sp2 + str(row_dict['endst']) + sp0)
            else:
                print(sp0 + 'Shutdown' + sp2 + str(row_dict['endst']) + sp1 + '' + sp1 + '' + sp0)

        if row_dict['downtime']:
            print(sp0 + 'Downtime' + sp2 + str(row_dict['downtime']) + sp0)

        if arg.kernel and row_dict['kernel']:
            print(sp0 + 'Kernel' + sp4 + str(row_dict['kernel']) + sp0)

        if not arg.csv:
            print('')


def print_table(db_rows, arg):
    """Print values as a table"""

    # Populate table with values to print
    tbl = [['No.', 'Boot ID', 'Startup Date', 'Uptime', 'Running', 'Sleeping', 'Shutdown Date', 'End', 'Downtime', 'Kernel']]
    al_left = [tbl[0].index('End'), tbl[0].index('Kernel')]  # Aligned to left

    if not arg.bootid:
        tbl[0].remove('Boot ID')

    if not arg.power:
        tbl[0].remove('Running')
        tbl[0].remove('Sleeping')

    if not arg.kernel:
        tbl[0].remove('Kernel')

    if not arg.csv:   # Add empty brake up line if csv is not used
        tbl.append([''] * len(tbl[0]))
    colpad = []
    side_spaces = 3

    db_rows = ordering_output(db_rows, arg)

    # Build table for print
    for row_dict in for_print(db_rows, arg):
        rowd = ([str(row_dict['startup']), str(row_dict['btime']), str(row_dict['uptime']),
                 str(row_dict['offbtime']), str(row_dict['endst']), str(row_dict['downtime'])])

        if 'Boot ID' in tbl[0]:
            rowd.insert(tbl[0].index('Boot ID'), str(row_dict['bootid']))

        if 'Running' in tbl[0]:
            rowd.insert(tbl[0].index('Running'), str(row_dict['rntime']))
            rowd.insert(tbl[0].index('Sleeping'), str(row_dict['slptime']))

        if 'Kernel' in tbl[0]:
            rowd.append(str(row_dict['kernel']))

        tbl.append(rowd)

    if not arg.csv:
        for i in range(len(tbl[0])):
            # Get the maximum width of the given column index
            colpad.append(max([len(str(row[i])) for row in tbl]))

        # Print cols by row
        for row in tbl:
            sys.stdout.write(str(row[0]).ljust(colpad[0]))  # First col print
            for i in range(1, len(row)):
                if i in al_left:  # Aligned side
                    col = (side_spaces * ' ') + str(row[i]).ljust(colpad[i])
                else:
                    col = str(row[i]).rjust(colpad[i] + side_spaces)
                sys.stdout.write(str('' + col))  # Other col print
            print('')
    else:
        for row in tbl:
            for key, value in enumerate(row):
                sys.stdout.write('"' + value + '"')
                if (key + 1) != len(row):
                    sys.stdout.write(',')
            print("")


def print_tat(db_rows, sis, arg):
    """Report system status at specific timestamp"""

    # Negative value decrease actual timestamp
    if arg.tat < 0:
        arg.tat = sis['btime'] + sis['uptime'] + arg.tat

    report = {'at': False, 'startup': False, 'status': False, 'time': False, 'time_fwd': False, 'time_total': False, 'bootid': None, 'kernel': None}

    for row in db_rows:
        report['at'] = arg.tat
        report['startup'] = row['startup']
        report['bootid'] = row['bootid']
        report['kernel'] = row['kernel']

        # Report UP if tat fall into btime + uptime range
        if (arg.tat >= row['btime']) and (arg.tat < (row['btime'] + row['uptime'])):
            report['status'] = 'UP'
            report['time'] = arg.tat - row['btime']
            report['time_fwd'] = row['uptime'] - report['time']
            report['time_total'] = row['uptime']
            break

        # Report DOWN if tat fall into offbtime + downtime range
        elif (arg.tat >= row['offbtime']) and (arg.tat < (row['offbtime'] + row['downtime'])):
            report['time'] = arg.tat - row['offbtime']
            report['time_fwd'] = row['downtime'] - report['time']
            if row['endst'] == 1:
                report['status'] = 'DOWN-OK'
            elif row['endst'] == 0:
                report['status'] = 'DOWN-BAD'
            else:
                report['status'] = 'DOWN'
            report['time_total'] = row['downtime']
            break

    if report['time'] is not False:

        perctg_1 = round(report['time'] * 100 / report['time_total'], arg.decp)
        perctg_2 = round(report['time_fwd'] * 100 / report['time_total'], arg.decp)

        if not arg.seconds:
            report['at'] = datetime.fromtimestamp(report['at']).strftime(arg.date_format)
            report['time'] = time_conv(report['time'])
            report['time_fwd'] = time_conv(report['time_fwd'])

        if not arg.csv:  # Define content/spaces between values
            sp0, sp2, sp5, sp8 = '', ':\t', '   ', ' '
        else:
            sp0, sp2, sp5, sp8 = '"', '","', '","', ''

        print(sp0 + 'Timestamp status' + sp2 + str(report['status']) + sp5 + 'at' + sp5 + str(report['at']) + sp5 + 'on' + sp5 + str(report['startup']) + sp0)
        if arg.bootid:
            print(sp0 + (sp8 * 6) + '...boot ID' + sp2 + str(report['bootid']) + sp0)
        if arg.kernel:
            print(sp0 + (sp8 * 2) + '...with kernel' + sp2 + str(report['kernel']) + sp0)
        print(sp0 + (sp8 * 6) + 'elapsed in' + sp2 + str(perctg_1) + '%' + sp5 + '-' + sp5 + str(report['time']) + sp0)
        print(sp0 + (sp8 * 4) + 'remaining in' + sp2 + str(perctg_2) + '%' + sp5 + '-' + sp5 + str(report['time_fwd']) + sp0)


def print_default(db_rows, sis, arg):
    """Print values as default output"""

    def extract_max_min_tst(db_rows, arg, tstamp):
        """Extract max and min timestamps values available"""

        if db_rows:
            first = db_rows[0]
            last = db_rows[-1]

        # Get max timestamp available
        if arg.tu is not None:
            tstamp['max'] = arg.tu
        elif last and last['offbtime'] is not False:
            tstamp['max'] = last['offbtime'] + last['downtime']
        elif last and last['btime'] is not False:
            tstamp['max'] = last['btime'] + last['uptime']
        else:
            tstamp['max'] = None

        # Get min timestamp available
        if arg.ts is not None:
            tstamp['min'] = arg.ts
        elif first and first['btime'] is not False:
            tstamp['min'] = first['btime']
        elif first and first['offbtime'] is not False:
            tstamp['min'] = first['offbtime'] - first['uptime']
        else:
            tstamp['min'] = tstamp['max']

        return tstamp

    # Initialize empty variables
    cal = {'tot': {'uptime': 0, 'rntime': 0, 'slptime': 0, 'downtime': 0},
           'ave': {'uptime': 0, 'rntime': 0, 'slptime': 0, 'downtime': 0}}
    rate = {'up': 0.0, 'rn': 0.0, 'spd': 0.0, 'down': 0.0}
    shdown = {'ok': 0, 'bad': 0}
    updown = {'startups': 0, 'shutdowns': 0}
    tstamp = {'max': 0, 'min': 0}
    cnt = {'kernel': [], 'bootid': []}
    sys_life = 0

    # Get values from db
    if db_rows:
        for row in db_rows:

            # Count startups
            updown['startups'] += 1

            # Count shutdowns when endst is set
            if row['endst'] is not False:
                if any((row['offbtime'], row['downtime'])):
                    if row['endst'] == 0:
                        shdown['bad'] += 1
                    if row['endst'] == 1:
                        shdown['ok'] += 1
                    updown['shutdowns'] += 1

            # Count totals
            cal['tot']['uptime'] += row['uptime']
            cal['tot']['rntime'] += row['rntime']
            cal['tot']['slptime'] += row['slptime']
            cal['tot']['downtime'] += row['downtime']

            # Lists with kernel names and boot_id identifiers
            cnt['kernel'].append(row['kernel'])
            cnt['bootid'].append(row['bootid'])

    # Get max/min timestamp
    tstamp = extract_max_min_tst(db_rows, arg, tstamp)

    # Get system life
    sys_life = cal['tot']['uptime'] + cal['tot']['downtime']

    # Get rates and average uptime / downtime
    if sys_life > 0:
        rate['up'] = round((cal['tot']['uptime'] * 100) / sys_life, arg.decp)
        rate['rn'] = round((cal['tot']['rntime'] * 100) / sys_life, arg.decp)
        rate['spd'] = round((cal['tot']['slptime'] * 100) / sys_life, arg.decp)
        rate['down'] = round((cal['tot']['downtime'] * 100) / sys_life, arg.decp)

    if updown['startups'] > 0:
        cal['ave']['uptime'] = int(round(float(cal['tot']['uptime'] / updown['startups']), 0))
        cal['ave']['rntime'] = int(round(float(cal['tot']['rntime'] / updown['startups']), 0))
        cal['ave']['slptime'] = int(round(float(cal['tot']['slptime'] / updown['startups']), 0))

    if updown['shutdowns'] > 0:
        cal['ave']['downtime'] = int(round(float(cal['tot']['downtime'] / updown['shutdowns']), 0))

    # Get kernel and boot_id counters, remove duplicate and empty elements
    cnt['kernel'] = len(set(filter(None, cnt['kernel'])))
    cnt['bootid'] = len(set(filter(None, cnt['bootid'])))

    # Ouput stlye: Apply human or keep seconds
    if not arg.seconds:
        if tstamp['max'] is not None:
            tstamp['max'] = datetime.fromtimestamp(tstamp['max']).strftime(arg.date_format)

        if tstamp['min'] is not None:
            tstamp['min'] = datetime.fromtimestamp(tstamp['min']).strftime(arg.date_format)

        # Look into the keys to set right values
        for k in cal:
            for key in cal[k]:
                cal[k][key] = time_conv(cal[k][key])

        sis['uptime'] = time_conv(sis['uptime'])
        sis['rntime'] = time_conv(sis['rntime'])
        sis['slptime'] = time_conv(sis['slptime'])
        sis['btime'] = datetime.fromtimestamp(sis['btime']).strftime(arg.date_format)
        sys_life = time_conv(sys_life)

    if not arg.csv:  # Define content/spaces between values
        sp0 = sp7 = ''
        sp1, sp2, sp3 = ':\t', ': \t', ': \t\t'
        sp4 = sp8 = ' '
        sp5 = '   '
    else:
        sp0, sp7, sp8 = '"', '","",""', ''
        sp1 = sp2 = sp3 = sp4 = sp5 = '","'

    if arg.power:
        pw1 = sp4 + '(r:' + str(cal['ave']['rntime']) + ' + s:' + str(cal['ave']['slptime']) + ')'
        pw2 = sp4 + '(r:' + str(sis['rntime']) + ' + s:' + str(sis['slptime']) + ')'
    else:
        pw1 = pw2 = ''

    if (arg.tu is not None or arg.until) and tstamp['max']:
        print(sp0 + 'System startups' + sp1 + str(updown['startups']) + sp5 + 'since' + sp5 + str(tstamp['min']) + sp5 + 'until' + sp5 + str(tstamp['max']) + sp0)
    else:
        print(sp0 + 'System startups' + sp1 + str(updown['startups']) + sp5 + 'since' + sp5 + str(tstamp['min']) + sp7)
    print(sp0 + 'System shutdowns' + sp1 + str(shdown['ok']) + sp4 + 'ok' + sp5 + '-' + sp5 + str(shdown['bad']) + sp4 + 'bad' + sp0)
    print(sp0 + 'System life' + sp3 + str(sys_life) + sp0)
    if arg.bootid:
        print(sp0 + 'System boot IDs' + sp2 + str(cnt['bootid']) + sp0)
    if arg.kernel:
        print(sp0 + 'System kernels' + sp2 + str(cnt['kernel']) + sp0)
    if not arg.csv:
        print('')

    print(sp0 + 'System uptime' + sp3 + str(rate['up']) + '%' + sp5 + '-' + sp5 + str(cal['tot']['uptime']) + sp0)
    if arg.power:
        print(sp0 + 'System power state' + sp1 + 'r:' + str(rate['rn']) + '% + s:' + str(rate['spd']) + '%' + sp5 + '-' + sp5 + 'r:' + str(cal['tot']['rntime']) + ' + s:' + str(cal['tot']['slptime']) + sp0)
    print(sp0 + 'System downtime' + sp2 + str(rate['down']) + '%' + sp5 + '-' + sp5 + str(cal['tot']['downtime']) + sp0)
    if not arg.csv:
        print('')

    print(sp0 + 'Average uptime' + sp2 + str(cal['ave']['uptime']) + pw1 + sp0)
    print(sp0 + 'Average downtime' + sp2 + str(cal['ave']['downtime']) + sp0)
    if arg.update:
        if not arg.csv:
            print('')
        print(sp0 + 'Current uptime' + sp2 + str(sis['uptime']) + pw2 + sp5 + 'since' + sp5 + str(sis['btime']) + sp0)
        if arg.bootid:
            print(sp0 + (sp8 * 4) + '...boot ID' + sp2 + str(sis['bootid']) + sp0)
        if arg.kernel:
            print(sp0 + '...with kernel' + sp2 + str(sis['kernel']) + sp0)


def main():
    """main entry point, core logic and database manage"""

    arg = get_arguments()

    sis = get_os_values()

    assure_state_db(sis, arg)

    db_conn = sqlite3.connect(arg.db_file)
    db_conn.row_factory = sqlite3.Row
    conn = db_conn.cursor()

    # Check if DB have the old format
    columns = [i[1] for i in conn.execute('PRAGMA table_info(tuptime)')]
    if 'rntime' and 'slptime' and 'bootid' not in columns:
        logging.warning('DB format outdated')
        upgrade_db(db_conn, conn, columns, arg)

    conn.execute('select bootid, btime, uptime, endst from tuptime where rowid = (select max(rowid) from tuptime)')
    prev = dict(zip(['bootid', 'btime', 'uptime', 'endst'], conn.fetchone()))
    prev['buptime'] = prev['btime'] + prev['uptime']

    logging.info('Last bootid from DB = %s', str(prev['bootid']))
    logging.info('Last btime from DB = %s', str(prev['btime']))
    logging.info('Last uptime from DB = %s', str(prev['uptime']))
    logging.info('Last buptime from DB = %s', str(prev['buptime']))
    logging.info('Last endst from DB = %s', str(prev['endst']))

    # - Test if system was resterted
    #
    # How tuptime does it:
    #
    #    If boot id exists (only on Linux nowadays), checking if its value changed.
    #
    #    Rest of the cases, checking if the value resultant from previous btime plus previous uptime
    #    (both saved into db) is lower than current btime or (to catch shutdowns lower than a second)
    #    equal to current btime and current uptime is lower than previous uptime
    #
    # Checking boot id is the most secure way to detect a new boot. Working with time values is not 100% relialible.
    # In some particular cases the btime value from /proc/stat or from the system clock functions may change.
    # It is affected by discontinuous jumps in the system time (e.g., if the system administrator manually changes
    # the clock), and by the incremental adjustments performed by adjtime(3) and NTP. Testing only prev btime vs
    # current btime can produce a false startup register, that's why is there the uptime value.
    # This issue also happen on virtualized enviroments, servers with high load or with high disk I/O. Also related
    # to kernel system clock frequency, computation of jiffies / HZ and the problema of lost ticks.
    # When tuptime doesn't register a new boot, only an update of the records, it tries to fix the drift.
    #
    # More info:
    #    https://tools.ietf.org/html/rfc1589
    #    https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=119971
    #    http://man7.org/linux/man-pages/man2/clock_gettime.2.html
    #    http://unix.stackexchange.com/questions/118631/how-can-i-measure-and-prevent-clock-drift
    #
    # To avoid lost an uptime record, please be sure that the system have time sync enabled, the init/systemd
    # script and the cron task works as expected.

    if arg.update:

        if prev['bootid'] and sis['bootid'] and prev['bootid'] != sis['bootid']:
            logging.info('System restarted = True from bootid')
            new_boot = True

        elif prev['buptime'] < sis['btime'] or (prev['buptime'] == sis['btime'] and sis['uptime'] < prev['uptime']):
            logging.info('System restarted = True from btime')
            new_boot = True

        else:
            logging.info('System restarted = False')
            new_boot = False

        if new_boot:
            # Adjust btime. Never lower than before
            if prev['buptime'] > sis['btime']:
                sis['btime'] = prev['buptime']

            sis['offbtime'] = prev['buptime']
            sis['downtime'] = sis['btime'] - prev['buptime']
            logging.info('Recording offbtime into DB = %s', str(sis['offbtime']))
            logging.info('Recording downtime into DB = %s', str(sis['downtime']))

            try:
                # Save downtimes for previous boot
                conn.execute('update tuptime set \
                             offbtime = ' + str(sis['offbtime']) + ', downtime = ' + str(sis['downtime']) +
                             ' where rowid = (select max(rowid) from tuptime)')

                # Create a new boot register
                conn.execute('insert into tuptime values (?,?,?,?,?,?,?,?,?)',
                             (str(sis['bootid']), str(sis['btime']), str(sis['uptime']),
                              str(sis['rntime']), str(sis['slptime']), None,
                              str(arg.endst), None, str(sis['kernel'])))
                logging.info('DB info = insert ok')

            except:
                # If you see this error, maybe the systemd script isn't executed at startup
                # or the db file (DB_FILE) have wrong permissions.
                logging.error('Detected a new system startup but the values have not been saved into DB.')
                logging.error('Tuptime execution user can\'t write into DB file: %s', str(arg.db_file))
                sys.exit(-1)

        else:
            # Adjust time drift. Check only when system wasn't restarted
            sis = control_drift(prev, sis)

            # If a graceful shutdown was just registered before, let 5 seconds to next update to avoid being overlaped
            # with regular schedule execution (it can happen at shutdown)
            if prev['endst'] and (prev['uptime'] + 5 > sis['uptime']) and not arg.endst:
                logging.info('DB info = graceful pass')
            else:
                try:
                    # Update current boot records
                    conn.execute('update tuptime set uptime = ' + str(sis['uptime']) +
                                 ', rntime = ' + str(sis['rntime']) + ', slptime = ' + str(sis['slptime']) +
                                 ', endst = ' + str(arg.endst) + ', kernel = \'' + str(sis['kernel']) +
                                 '\' where rowid = (select max(rowid) from tuptime)')
                    logging.info('DB info = update ok')

                except sqlite3.OperationalError:
                    logging.info('DB info = update skip')
    else:
        logging.info('DB info = skip by arg.update')

    db_conn.commit()

    # Exit if silent is enabled. Avoid wasting time in print operations
    if arg.silent:
        db_conn.close()
        logging.info('Silent mode')
        sys.exit(0)

    # Get all rows to determine print values. Convert from sqlite row object to dict to allow item allocation
    conn.execute('select rowid as startup, * from tuptime')
    db_rows = [dict(row) for row in conn.fetchall()]
    db_conn.close()

    if len(db_rows) != db_rows[-1]['startup']:  # Real startups are not equal to enumerate startups
        logging.info('Possible deleted rows in DB')

    if arg.update:
        # If the user can only read db, the previous select return outdated numbers in last row
        # because the db was not updated previously. The following snippet update that in memmory
        db_rows[-1]['uptime'] = sis['uptime']
        db_rows[-1]['rntime'] = sis['rntime']
        db_rows[-1]['slptime'] = sis['slptime']
        db_rows[-1]['endst'] = arg.endst
        db_rows[-1]['kernel'] = sis['kernel']
        db_rows[-1]['offbtime'] = False
        db_rows[-1]['downtime'] = False
    else:
        # Convert last line None sqlite registers to False
        for key in db_rows[-1].keys():
            if db_rows[-1][key] is None:
                db_rows[-1][key] = False

    # Parse since until arguments
    if arg.until:
        db_rows, arg = until_opt(db_rows, arg)
    if arg.since:
        db_rows, arg = since_opt(db_rows, arg)

    if arg.tu is not None:
        db_rows, arg = tuntil_opt(db_rows, sis, arg)
    if arg.ts is not None:
        db_rows, arg = tsince_opt(db_rows, sis, arg)

    # Print values
    if arg.lst:
        print_list(db_rows, arg)
    elif arg.table:
        print_table(db_rows, arg)
    elif arg.tat is not None:
        print_tat(db_rows, sis, arg)
    else:
        print_default(db_rows, sis, arg)


if __name__ == "__main__":
    main()
